## 内存管理

其实核心就是**池化技术**，一次性向操作系统申请一批连续的内存空间，每次需要创建对象的时候就在这批空间内找到空闲的内存块进行分配，对象释放的时候就将对应的内存块标记为空闲，这样就避免了每次都向操作系统申请和释放内存，只要程序中总的对象内存空间稳定，Python 向操作系统申请和释放内存的频率就会很低。

这种方案是不是很熟悉，数据库连接池也是类似的思路。一般后端应用程序也是提前跟数据库建立多个连接，每次执行 SQL 的时候就从中找一个可用的连接与数据库进行交互，SQL 完成的时候就将连接交还给连接池，如果某个连接长时间未被使用，连接池就会将其释放掉。本质上，这些都是用空间换时间，消耗一些不算太大的内存，降低诸如内存申请和 TCP 建立连接等耗时操作的频率，提高程序整体的运行速度。

Python 内存管理器对内存进行了分层，从大到小分别为 arena、pool 和 block。arena 是内存管理器直接调用 malloc() 或 calloc() 向操作系统申请的一大块内存，Python 中对象的创建和释放都是在 arena 中进行分配和回收。在 arena 内部又分成了多个 pool，每个 pool 内又分成了多个大小相等的 block，每次分配内存的时候都是从某个 pool 中选择一块可用的 block 返回。每个 pool 内的 block 的大小是相等的，不同 pool 的 block 大小可以不等。

![](https://img2022.cnblogs.com/blog/2045526/202205/2045526-20220522123338692-1336587934.svg)

<br/>

## 内存回收

CPython 中主要的垃圾回收算法是**引用计数**。

引用计数顾名思义就是统计每个对象有多少个引用，每个引用可能来自另外一个对象，或者一个全局（或静态）C 变量，或者 C 语言函数中的局部变量。

当一个变量的引用计数变成 0，那么这个对象就会被释放。如果被释放的对象包含对其他对象的引用，那么其他对象的引用计数就会相应地减 1。如果其他对象的引用计数在减 1 之后变成 0，这些对象也会级联地被释放掉。在 Python 代码中可以通过 sys.getrefcount 函数获取一个对象的引用计数（函数的返回值会比实际的引用计数多 1，因为函数本身也包含一个对目标对象的引用）。

```python
>>> x = object()
>>> sys.getrefcount(x)
2
>>> y = x
>>> sys.getrefcount(x)
3
>>> del y
>>> sys.getrefcount(x)
2
```

<br/>

---

https://www.cnblogs.com/zikcheng/p/16297610.html （Python 中的内存管理 ）

https://www.cnblogs.com/zikcheng/p/17071380.html  （Python 的垃圾回收机制）
