### 索引部分汇总：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png)

<br/>

	---

### B+树：

![](https://cdn.xiaolincoding.com//mysql/other/7c635d682bd3cdc421bb9eea33a5a413.png)

- 特点：
  - 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
  - 非叶子节点分为不同层次，通过分层来降低每一层的搜索量。
  - 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询。
    
    <br/>

InnoDB 的数据是按「数据页」为单位来读写的，**默认数据页大小为 16 KB**。每个数据页之间通过**双向链表**的形式组织起来，物理上不连续，但是逻辑上连续。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

1. B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
2. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在**插入、删除**的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
3. B+ 树叶子节点之间用链表连接了起来，有利于**范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

### 锁

#### 类型：

- 全局锁
  ```mysql
  flush tables with read lock
  ```
  
  执行之后，整个数据库就变成**只读状态**。
- 表级锁
  - 表锁
    
    需要注意的是，表锁除了会限制**别的线程的读写外**，也会限制**本线程接下来的读写操作**。
    ```mysql
    //表级别的共享锁，也就是读锁；
    lock tables t_student read;
    
    //表级别的独占锁，也就是写锁；
    lock tables t_stuent write;
    ```
  - 元数据锁（MDL）
    
    我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
    ```
    对一张表进行 CRUD 操作时，加的是 MDL 读锁；
    对一张表做结构变更操作的时候，加的是 MDL 写锁；
    ```
    
    MDL 是在事务提交后才会释放，**这意味着事务执行期间，MDL 是一直持有的。**
  - 意向锁
  - AUTO-INC 锁
- 行级锁
  - Record Lock
  - Gap Lock
  - Next-Key Lock
  - 插入意向锁

<br/>

#### 如何避免死锁？

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。

- **设置事务等待锁的超时时间**。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。
- **开启主动死锁检测。**主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。
