## 1、基本概念

### 1.0 Redis 和 Memcached 有什么区别？

||redis|memcached|
|--|--|--|
|数据类型|String、Hash、List、Set、ZSet|key-value|
|持久化|可持久到磁盘|仅内存中|
|高可用|支持集群模式|无集群模式|
|特性|订阅模型、Lua 脚本、事务等功能|/|

### 1.1 数据结构

- String（字符串）
- Hash（哈希）
- List（列表）
- Set（集合）
- Zset（有序集合）

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

###  1.2 线程模型

Redis **单线程**指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg)

单线程还这么快（单线程的 Redis 吞吐量可以达到 10W/每秒）原因：

- Redis 的大部分操作都在**内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽
- Redis 采用单线程模型可以**避免了多线程之间的竞争**
- Redis 采用了** I/O 多路复用机制处理大量的客户端 Socket 请求**，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。

### 　1.3 持久化

- AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
  
  ![](https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png)
  
  <br/>
- RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
  
  RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。因此在 Redis 恢复数据时，** RDB 恢复数据的效率会比 AOF 高些**，因为直接将 RDB 文件读入内存就可以。
  
  Redis 提供了两个命令来生成 RDB 文件，**分别是 save 和 bgsave**，他们的区别就在于是否在「主线程」里执行：
  - 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
  - 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；

- 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；
  
  **RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。**
  
  **AOF 优点是丢失数据少，但是数据恢复不快。**
  
  使用了混合持久化，**AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。**
  
  这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。
  
  优点：混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。
  
  缺点：AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。

##  2、击穿、穿透、雪崩

- Redis 击穿 ： 访问Redis和mysql**不存在的数据**，Redis无法直接拦截，直接穿透到数据库，导致数据库压力过大宕机。
- Redis 穿透 ： Redis中的**热点数据**突然过期失效，持续的高并发访问就击破缓存直接访问数据库，导致数据库宕机。
- Redis 雪崩： Redis中的**大量key集中过期**，导致Redis服务出现性能瓶颈。

以上三种现象，他们的共同点和不同点如下：

- 共同点：其实都是跟key 有关系，一个核心点都是key不存在了，流量直接打到数据库上，导致数据库宕机。
- 不同点：Redis 击穿是mysql和Redis 上都不存在数据的情况下，Redis 无法连接，流量直接打到mysql上，导致宕机
  
  <br/>

Redis 穿透是Redis 的数据突然失效了，这个失效有可能是key 被删除，key过期，都会导致这种现象的出现，不过这里的key是**热点key**，而且必须是热点key，不然现象就有点像Redis 雪崩了。

Redis 雪崩 是Redis 的key 大范围的过期，是Redis 自身清理过期key进入的一种状态，此时如果有业务访问Redis，Redis反应会比往上慢很多，而且这种现象很独特，今天就特别的谈谈Redis 雪崩

<br/>

在细谈Redis 雪崩前，我们先了解了解Redis key的过期策略： 惰性删除和定期删除

- 惰性删除： 可以理解为不主动的删除，是业务在访问某个key时，会检查该key是否过期，如果不过期，把读取到的数据反馈给客户端。如果key过期了，会把key不存在的信息反馈给客户端，然后把key删除。这样的一个动作就是 惰性删除。惰性删除对Redis cpu 影响不大，但是对内存不够友好，因为某些已经过期的key没有被访问，就会继续的留在内存中。
- 定期删除：定期删除是Redis的主动删除，Redis会根据参数hz的设置，定期的扫描key中的记录。hz默认设置为10，Redis数据库会以100ms为单位，从众多key中随机选择20个key来计算过期时间。如果key过期了，就把它删除。这就是定期删除策略。

<br/>

### 预防雪崩

1. 防止出现雪崩
   
   雪崩的一个主要特性就是key 过期率(过期率=已过期key的总量/key的总量)超过25%，在日常的使用中，过期的key 是不短的增加的，key的过期率会处于25%左右，想要避免出现雪崩是比较困难的。**我们只要控制在某个时间内key的过期率小于25%时**，是可以减缓雪崩的出现。因此设置过期时间是一个比较关键的问题。那么如何设置过期时间呢？如果有1百万的key 要过期，我们怎么设置过期时间呢？
   
   本例中5w/s的del命令，把Redis cpu 直接满负载运行，如果我们可以控制每秒删除命令数，比如1w，这样的话，cpu 就不会处于100%的运行状态。如果我们要在某个时间点过期X万key，为了不让cpu 处于100%的状态，我们设定每秒删除1w个key，这样我们可以得到删除key的区间时间t：
   ```
      t=X(w)/1(w)s   w=为单位万   t 的单位为s(秒)
   ```
   
   这样Redis cpu 就不会处于满负荷的状态下运行。其实这里t 秒也是比较难控制的，毕竟每秒内被扫描到也比较随机，而且在Redis实例中，被过期的key 也不可能就是我们指定的。也会存在其他的key，因此，我们可以根据业务，尽可能大的设定过期区间，比如半个小时、1个小时...,尽可能不要在某个时间点集中过期，以免影响业务。
2. 雪崩出现后，如何减缓对数据库的影响。
   
   既然我们知道雪崩不易避免，那么雪崩出现后，我们应如何减少影响呢？雪崩出现后，Redis 已经没有相关key了，业务从Redis中获取不到数据，我们通常的做法是，业务服务直接访问数据库，瞬间的压力会直接让数据库停止服务。因为减少数据库的访问是解决方案。
   
   我们可以设定访问Redis 无数据时，**直接反馈给业务一种特殊的状态**，然后向业务记录数据不存在的信息，让业务单进程访问数据库，把拉去的数据放入Redis中，减少服务请求从Redis直接回源至数据库，导致整个服务处于不可用的状态中。

##  3、高可用

- 主从复制
  
  所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。
  
  主从服务器之间的命令复制是**异步**进行的。
  ```
  具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。
  但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，
  而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。
  如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。
  ```

		![](https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d.png)

<br/>

- 哨兵模式
  
  哨兵模式做到了可以**监控主从服务器，并且提供主从节点故障转移的功能**。
  
  ![](https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4.png)
  
  <br/>
- 切片集群
  
   在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽.
  
  根据键值对的 key，按照 CRC16 算法 (opens new window)计算一个 16 bit 的值。
  
  再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。
  
  eg：切片集群一共有 2 个节点，假设有 4 个哈希槽（Slot 0～Slot 3）

	![](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%98%A0%E5%B0%84%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB.jpg)
