## CURD
```sql
CREATE TABLE `student_tbl` (
  `student_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `student_name` varchar(100) NOT NULL,
  `student_score` varchar(40) NOT NULL,
  `student_sex` varchar(40) NOT NULL,
  `student_date` date DEFAULT NULL,
  `leader` int(10) DEFAULT NULL,
  PRIMARY KEY (`student_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8

```


```sql
insert into base_test.student_tbl 
(student_name,student_score,student_sex) 
values ("qwe",23,"male");
```

```sql
delete from base_test.student_tbl where student_id=7;
```

```sql
SELECT * 
FROM base_test.student_tbl 
where student_score > 
(select avg(student_score) from base_test.student_tbl);
```

```sql
SELECT * 
FROM `student_tbl` INNER JOIN `runoob_tbl`
ON student_tbl.`student_score` = `runoob_tbl`.`runoob_score`
ORDER BY student_tbl.`student_score` DESC
```

```sql
SELECT
(SELECT COUNT(1) FROM `student_tbl` WHERE `student_sex` = 'male') AS "boy", 
(SELECT COUNT(*) FROM `student_tbl` WHERE `student_sex` = 'female') AS "girl"

select gender,count(*) from student group by gender;
```

```sql
UPDATE `student_tbl` 
SET student_name='qwe',student_score=111
WHERE student_id =1;
```

## 一、事务

ACID

1. 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

<br/>

2. 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
   
   <br/>
3. 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。
   
   <br/>
4. 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
   
   <br/>

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

<br/>

## 二、并发一致性问题

<br/>

### **丢失修改**

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

<br/>

### 读脏数据

读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

<br/>

### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<br/>

### 幻影读

幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

<br/>

## 三、锁

1. 读写锁
互斥锁（Exclusive），简写为 X 锁，又称写锁。
共享锁（Shared），简写为 S 锁，又称读锁。
   
   
有以下两个规定：

一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

## 四、隔离级别

### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

<br/>

### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

<br/>

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。

<br/>

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行
